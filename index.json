[{"categories":["Kubernetes"],"content":"这篇文章总结了 Kubernetes 中 命令行的使用。","date":"2020-08-06","objectID":"/kubectl/","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"这篇文章总结了 Kubernetes 中 命令行的使用。 趁着今年黑色星期五的 Linux CNCF 社区报名有三五折优惠，我打算报考 CKAD 认证考试。在学习 Kubernetes 相关知识的同时，我也不忘总结一波有关 kubectl 的快捷命令。 ","date":"2020-08-06","objectID":"/kubectl/:0:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"1 Pod 生命周期管理 # 命令行创建 nginx pod kubectl run nginx --image=nginx --restart=Never --dry-run=client -n mynamespace -o yaml \u003e pod.yaml # 获取所有命名空间的 pod kubectl get po --all-namespaces # 运行 busybox 的同时打印 hello world kubectl run busybox --image=busybox -it --restart=Never -- echo 'hello world' # 进入容器 kubectl exec -it podName -n nsName /bin/sh # 列出 pod container 里面的 env variable kubectl exec podName -- printenv # 创建 pod 同时为 pod 添加标签 kubectl run nginx1 --image=nginx --restart=Never --labels=app=v1 # 列出所有添加标签的 pods kubectl get po --show-labels # 列出标有 app=v2 的 pods kubectl get po -l app=v2 # 更改 nginx2 的标签为 app=v2 kubectl label po nginx2 app=v2 --overwrite # 移除 nginx1 标有app的标签 kubectl label po nginx1 app- ","date":"2020-08-06","objectID":"/kubectl/:1:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"2 暴露 service 或 deployment # 输出为yaml文件（推荐） kubectl expose deployment nginx --port=80 --type=NodePort --target-port=80 --name=web1 -o yaml \u003e web1.yaml # 暴露端口 kubectl expose deployment nginx -n bigdata --port=80 --type=NodePort ","date":"2020-08-06","objectID":"/kubectl/:2:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"3 版本更新 # 更新 nginx 版本 kubectl set image deployment/nginx nginx=nginx:1.15 # 滚动更新 kubectl rolling-update frontend --image=image:v2 # 扩缩容 kubectl scale deployment nginx --replicas=10 ","date":"2020-08-06","objectID":"/kubectl/:3:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"4 回滚 # 查看更新过程 kubectl rollout status deployment/nginx --namespace=nsName # 如果更新成功, 返回值为0 kubectl rollout status deployment nginx-deployment --watch=false | grep -ic waiting # 查看变更历史版本信息 kubectl rollout history deployment/nginx kubectl rollout history deployment/nginx --revision=3 --namespace=nsName # 终止升级 kubectl rollout pause deployment/nginx --namespace=nsName # 继续升级 kubectl rollout resume deployment/review-demo --namespace=nsName # 回滚版本 kubectl rollout undo deployment/nginx --namespace=nsName kubectl rollout undo deployment/nginx --to-revision=3 --namespace=nsName ","date":"2020-08-06","objectID":"/kubectl/:4:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"5 探针 livenessProbe 和 readinessProbe kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml \u003e pod.yaml # 然后编辑 pod.yaml 下的(containers -\u003e livenessProbe -\u003e exec -\u003e command -\u003e - 命令) 并保存 kubectl describe pod nginx | grep -i liveness # 检测是否 nginx 存活 ","date":"2020-08-06","objectID":"/kubectl/:5:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"6 Kubernetes configuration 配置 # 创建 secret kubectl create secret generic test-secret --from-literal='username=my-app' --from-literal='password=39528$vdg7Jb' # 创建 configMap echo -e \"DB_URL=localhost:3306\\nDB_USERNAME=postgres\" \u003e config.txt kubectl create cm db-config --from-env-file=config.txt # 创建 UID = 101 kubectl run nginx --image=nginx --restart=Never --dry-run=client -o yaml \u003e pod.yaml vi pod.yaml # spec -\u003e securityContext -\u003e runAsUser -\u003e 101 # requests 和 limits kubectl run nginx --image=nginx --restart=Never --requests='cpu=100m,memory=256Mi' --limits='cpu=200m,memory=512Mi' # 创建名字为 myuser 的 serviceAccount 并将它用在 nginx pod 上 kubectl create sa myuser kubectl run nginx --image=nginx --restart=Never --serviceaccount=myuser -o yaml --dry-run=client \u003e pod.yaml kubectl apply -f pod.yaml ","date":"2020-08-06","objectID":"/kubectl/:6:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"7 资源存储和分配 # pv 模板apiVersion:v1kind:PersistentVolumemetadata:name:task-pv-volumelabels:type:localspec:storageClassName:manualcapacity:storage:10GiaccessModes:- ReadWriteOncehostPath:path:\"/mnt/data\"--# pvc 模板apiVersion:v1kind:PersistentVolumeClaimmetadata:name:task-pv-claimspec:storageClassName:manualaccessModes:- ReadWriteOnceresources:requests:storage:3Gi# 区别在于:# pv: spec -\u003e capacity -\u003e storage 和 spec -\u003e hostPath -\u003e path# pvc: spec -\u003e resources -\u003e requests -\u003e storage ","date":"2020-08-06","objectID":"/kubectl/:7:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"8 表格汇总 类型 命令 描述 基础命令 create 通过文件名或标准输入创建资源 expose 将一个资源公开为一个新的Service run 在集群中运行一个特定的镜像 set 在对象上设置特定的功能 get 显示一个或多个资源 explain 文档参考资料 edit 使用默认的编辑器编辑资源 delete 通过文件名、标准输入、资源名称或标签选择器来删除资源 部署命令 rollout 管理资源的发布 rolling-update 对给定的复制控制器滚动更新 scale 扩容或缩容Pod、Deployment、ReplicaSet、RC或Job autoscale 创建一个自动选择扩容或缩容并设置Pod数量 集群管理命令 certificate 修改证书资源 cluster-info 显示集群信息 top 显示资源（CPU、Memory、Storage）使用。需要Heapster运行 cordon 标记节点不可调度 uncordon 标记节点可调度 drain 维护期间排除节点（驱除节点上的应用，准备下线维护） taint 设置污点属性 故障诊断和调试命令 describe 显示特定资源或资源组的详细信息 logs 在一个Pod中打印一个容器日志。如果Pod只有一个容器，容器名称是可选的 attach 附加到一个运行的容器 exec 执行命令到容器 port-forward 转发一个或多个本地端口到一个Pod proxy 运行一个proxy到Kubernetes API Server cp 拷贝文件或目录到容器 auth 检查授权 高级命令 apply 通过文件名或标准输入对资源应用配置 patch 使用补丁修改、更新资源的字段 replace 通过文件名或标准输入替换一个资源 convert 不同的API版本之间转换配置文件 设置命令 label 更新资源上的标签 annotate 更新资源上的注释 completion 用于实现kubectl工具自动补全 其他命令 api-versions 打印支持的API版本 config 修改kubeconfig文件（用于访问API，比如配置认证信息） help 所有命令帮助 plugin 运行一个命令行插件 version 打印客户端和服务版本信息 ","date":"2020-08-06","objectID":"/kubectl/:8:0","tags":["Kubernetes","kubectl"],"title":"Kubernetes kubectl 命令行总结","uri":"/kubectl/"},{"categories":["Kubernetes"],"content":"这篇文章总结了 Kubernetes 中 CRD 的知识体系和其中的底层实现等等。","date":"2020-08-04","objectID":"/k8s/","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"这篇文章总结了 Kubernetes 中 CRD 的知识体系和其中的底层实现等等。 ","date":"2020-08-04","objectID":"/k8s/:0:0","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"1 初识 CRD 和 Operator 框架 ","date":"2020-08-04","objectID":"/k8s/:1:0","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"1.Custom Resource Define Custom Resource Define 简称 CRD，是 Kubernetes（v1.7+）为提高可扩展性，让开发者去自定义资源的一种方式。CRD 资源可以动态注册到集群中，注册完毕后，用户可以通过 kubectl 来创建访问这个自定义的资源对象，类似于操作 Pod 一样。不过需要注意的是 CRD 仅仅是资源的定义而已，需要一个对应的控制器去监听 CRD 的各种事件来添加自定义的业务逻辑。 ","date":"2020-08-04","objectID":"/k8s/:1:1","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"2.YAML 文件格式 我们可以定义一个如下所示的 CRD 资源清单文件： # crd-demo.yamlapiVersion:apiextensions.k8s.io/v1kind:CustomResourceDefinitionmetadata:# name 必须匹配下面的spec字段：\u003cplural\u003e.\u003cgroup\u003e name:crontabs.stable.example.comspec:# group 名用于 REST API 中的定义：/apis/\u003cgroup\u003e/\u003cversion\u003e group:stable.example.com# 列出自定义资源的所有 API 版本 versions:- name:v1beta1 # 版本名称，比如 v1、v2beta1 等等 served:true# 是否开启通过 REST APIs 访问 `/apis/\u003cgroup\u003e/\u003cversion\u003e/...` storage:true# 必须将一个且只有一个版本标记为存储版本 schema:# 定义自定义对象的声明规范 openAPIV3Schema:description:Define CronTab YAML Spectype:objectproperties:spec:type:objectproperties:cronSpec:type:stringimage:type:stringreplicas:type:integer# 定义作用范围：Namespaced（命名空间级别）或者 Cluster（整个集群） scope:Namespacednames:# kind 是 singular 的一个驼峰形式定义，在资源清单中会使用 kind:CronTab# plural 名字用于 REST API 中的定义：/apis/\u003cgroup\u003e/\u003cversion\u003e/\u003cplural\u003e plural:crontabs# singular 名称用于 CLI 操作或显示的一个别名 singular:crontab# shortNames 相当于缩写形式 shortNames:- ct 我们在创建资源的时候，肯定不是任由我们随意去编写 YAML 文件的，当我们把上面的 CRD 文件提交给 Kubernetes 之后，Kubernetes 会对我们提交的声明文件进行校验，从定义可以看出 CRD 是基于 OpenAPI v3 schem 进行规范的。 使用 kubectl 来创建这个 CRD 资源清单： [root@master ~]# kubectl apply -f crd-demo.yaml customresourcedefinition.apiextensions.k8s.io/crontabs.stable.example.com created 然后我们就可以使用这个 API 端点来创建和管理自定义的对象，这些对象的类型就是上面创建的 CRD 对象规范中的 CronTab。 现在在 Kubernetes 集群中我们就多了一种新的资源叫 crontabs.stable.example.com，我们就可以使用它来定义一个 CronTab 资源对象了，这个自定义资源对象里面可以包含的字段我们在定义的时候通过 schema 进行了规范，比如现在我们来创建一个如下所示的资源清单： # crd-crontab-demo.yamlapiVersion:\"stable.example.com/v1beta1\"kind:CronTabmetadata:name:my-new-cron-objectspec:cronSpec:\"* * * * */5\"image:my-awesome-cron-image 直接创建这个对象： [root@master ~]# kubectl apply -f crd-crontab-demo.yaml crontab.stable.example.com/my-new-cron-object created 我们就可以用 kubectl 来管理我们这里创建 CronTab 对象了，比如： [root@master ~]# kubectl get ct # 简写 NAME AGE my-new-cron-object 42s [root@master ~]# kubectl get crontab NAME AGE my-new-cron-object 88s ","date":"2020-08-04","objectID":"/k8s/:1:2","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"3.kubebuilder 脚手架使用 创建一个目录，然后在里面运行 kubebuilder init 命令，初始化一个新项目。 $ cd go/src/github.com/peterliao96 $ mkdir builder-demo $ cd builder-demo # 开启 go modules $ export GO111MODULE=on $ export GOPROXY=https://goproxy.cn $ kubebuilder init --domain ydzs.io --owner peterliao96 --repo github.com/peterliao96/builder-demo # 创建一个新的 API（组/版本）为 “webapp/v1”，并在上面创建新的 Kind(CRD) “Guestbook” $ kubebuilder create api --group webapp --version v1 --kind Guestbook 上面的命令会创建文件 api/v1/guestbook_types.go，该文件中定义相关 API ，而针对于这一类型 (CRD) 的业务逻辑生成在 controller/guestbook_controller.go 文件中。 我们可以根据自己的需求去修改资源对象的定义结构，修改 api/v1/guestbook_types.go 文件： // api/v1/guestbook_types.go package v1 import ( metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\" ) // EDIT THIS FILE! THIS IS SCAFFOLDING FOR YOU TO OWN! // NOTE: json tags are required. Any new fields you add must have json tags for the fields to be serialized. // GuestbookSpec defines the desired state of Guestbook type GuestbookSpec struct { // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster // Important: Run \"make\" to regenerate code after modifying this file // Foo is an example field of Guestbook. Edit guestbook_types.go to remove/update Foo string `json:\"foo,omitempty\"` } // GuestbookStatus defines the observed state of Guestbook type GuestbookStatus struct { // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster // Important: Run \"make\" to regenerate code after modifying this file } //+kubebuilder:object:root=true //+kubebuilder:subresource:status // Guestbook is the Schema for the guestbooks API type Guestbook struct { metav1.TypeMeta `json:\",inline\"` metav1.ObjectMeta `json:\"metadata,omitempty\"` Spec GuestbookSpec `json:\"spec,omitempty\"` Status GuestbookStatus `json:\"status,omitempty\"` } //+kubebuilder:object:root=true // GuestbookList contains a list of Guestbook type GuestbookList struct { metav1.TypeMeta `json:\",inline\"` metav1.ListMeta `json:\"metadata,omitempty\"` Items []Guestbook `json:\"items\"` } func init() { SchemeBuilder.Register(\u0026Guestbook{}, \u0026GuestbookList{}) } 本部分摘录于 Kubernetes 开发课文档中的 CRD介绍 和 kubebuilder 介绍。 ","date":"2020-08-04","objectID":"/k8s/:1:3","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"2 client-go 实现原理 我们自定义的资源 CRD 创建完成以后，其实如果没有一个 controller 运行它的话，它并没有起到任何用处。于是，我们需要通过创建 controller 来运行 CRD。 要想了解 controller 的实现原理和方式，我们就需要了解下 client-go 这个库的实现，Kubernetes 部分代码也是基于这个库实现的，也包含了开发自定义控制器时可以使用的各种机制。 下图显示了 client-go 中的各个组件是如何公众的以及与我们要编写的自定义控制器代码的交互入口： 图1:client-go 实现流程图controller interaction \" 图1:client-go 实现流程图 ","date":"2020-08-04","objectID":"/k8s/:2:0","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"1. 组件介绍 client-go 组件： Reflector：通过 Kubernetes API 监控 Kubernetes 的资源类型 采用 List/Watch 机制, 可以 Watch 任何资源包括 CRD 添加 object 对象到 FIFO 队列，然后 Informer 会从队列里面取数据 Informer：controller 机制的基础，循环处理 object 对象 从 Reflector 取出数据，然后将数据给到 Indexer 去缓存，提供对象事件的 handler 接口，只要给 Informer 添加 ResourceEventHandler 实例的回调函数，去实现 OnAdd(obj interface{})、 OnUpdate(oldObj, newObj interface{}) 和 OnDelete(obj interface{}) 这三个方法，就可以处理好资源的创建、更新和删除操作了。 Indexer：提供 object 对象的索引，是线程安全的，缓存对象信息 controller 组件： Informer reference: controller 需要创建合适的 Informer 才能通过 Informer reference 操作资源对象 Indexer reference: controller 创建 Indexer reference 然后去利用索引做相关处理 Resource Event Handlers：Informer 会回调这些 handlers Work queue: Resource Event Handlers 被回调后将 key 写到工作队列，这里的 key 相当于事件通知，后面根据取出事件后，做后续的处理 Process Item：从工作队列中取出 key 后进行后续处理，具体处理可以通过 Indexer reference controller 可以直接创建上述两个引用对象去处理，也可以采用工厂模式，官方都有相关示例 ","date":"2020-08-04","objectID":"/k8s/:2:1","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Kubernetes"],"content":"2. 自定义 Controller 的控制流 图2：controller 工作流controller workflow \" 图2：controller 工作流 如上图所示主要有两个部分，一个是发生在 SharedIndexInformer 中，另外一个是在自定义控制器中。 Reflector 通过 Kubernetes APIServer 执行对象（比如 Pod）的 ListAndWatch 查询，记录和对象相关的三种事件类型 Added、Updated、Deleted，然后将它们传递到 DeltaFIFO 中去。 DeltaFIFO 接收到事件和 watch 事件对应的对象，然后将他们转换为 Delta 对象，这些 Delta 对象被附加到队列中去等待处理，对于已经删除的，会检查线程安全的 store 中是否已经存在该文件，从而可以避免在不存在某些内容时排队执行删除操作。 Cache 控制器（不要和自定义控制器混淆）调用 Pop() 方法从 DeltaFIFO 队列中出队列，Delta 对象将传递到 SharedIndexInformer 的 HandleDelta() 方法中以进行进一步处理。 根据 Delta 对象的操作（事件）类型，首先在 HandleDeltas 方法中通过 indexer 的方法将对对象保存到线程安全的 Store 中，然后，通过 SharedIndexInformer 中的 sharedProcessor 的 distribution() 方法将这些对象发送到事件 handlers，这些事件处理器由自定义控制器通过 SharedInformer 的方法比如 AddEventHandlerWithResyncPeriod() 进行注册。 已注册的事件处理器通过添加或更新时间的 MetaNamespaceKeyFunc() 或删除事件的 DeletionHandingMetaNamespaceKeyFunc() 将对象转换为格式为 namespace/name 或只是 name 的 key，然后将这个 key 添加到自定义控制器的 workqueue 中，workqueues 的实现可以在 util/workqueue 中找到。 自定义的控制器通过调用定义的 handlers 处理器从 workqueue 中 pop 一个 key 出来进行处理，handlers 将调用 indexer 的 GetByKey() 从线程安全的 store 中获取对象，我们的业务逻辑就是在这个 handlers 里面实现。 本部分摘录于 Kubernetes 文档中的 CRD controller 原理实现。 ","date":"2020-08-04","objectID":"/k8s/:2:2","tags":["Golang","Kubernetes","CRD"],"title":"Kubernetes CRD Operator 开发系列","uri":"/k8s/"},{"categories":["Golang"],"content":"这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。","date":"2020-08-02","objectID":"/golang/","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。 说起 Golang， 大家都会第一时间想到高并发和 Golang 作为主流的后端开发语言的优势，本文主要讲 Golang 主要知识体系，包括数组和切片、协程的调度原理、等待组 waitGroup、channel 的底层实现、互斥锁 mutex 的实现、interface 中的多态等等。 ","date":"2020-08-02","objectID":"/golang/:0:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1 数组和切片 ","date":"2020-08-02","objectID":"/golang/:1:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. 切片的本质 切片的本质就是对底层数组的封装，它包含了三个信息 底层数组的指针 切片的长度(len) 切片的容量(cap) 切片的容量指的是数组中的头指针指向的位置至数组最后一位的长度。举个例子，现在有一个数组 a := [8]int {0,1,2,3,4,5,6,7}，切片 s1 := a[:5]，相应示意图如下 图1: 切片 s1 和底层数组 a切片 s1 和底层数组 a \" 图1: 切片 s1 和底层数组 a 切片 s2 := a[3:6]，相应示意图如下： 图2：切片 s2 和底层数组 a切片 s2 和底层数组 a \" 图2：切片 s2 和底层数组 a ","date":"2020-08-02","objectID":"/golang/:1:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. 切片的扩容 Go 中切片扩容的策略是这样的： 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。 注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。 举例 // make()函数创建切片 fmt.Println() var slices = make([]int, 4, 8) //[0 0 0 0] fmt.Println(slices) // 长度：4, 容量8 fmt.Printf(\"长度：%d, 容量%d\", len(slices), cap(slices)) 需要注意的是，golang 中没办法通过下标来给切片扩容，如果需要扩容，需要用到 append slices2 := []int{1,2,3,4} slices2 = append(slices2, 5) fmt.Println(slices2) // 输出结果 [1 2 3 4 5] 同时切片还可以将两个切片进行合并 // 合并切片 slices3 := []int{6,7,8} slices2 = append(slices2, slices3...) fmt.Println(slices2) // 输出结果 [1 2 3 4 5 6 7 8] ","date":"2020-08-02","objectID":"/golang/:1:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3. 切片的传递问题 切片本身传递给函数形参时是引用传递，但 append 后，切片长度变化时会被重新分配内存，而原来的切片还是指向原来地址，致使与初始状况传进来的地址不一样，要想对其值有改变操作，需使用指针类型操作。 我们来看一道 leetcode 78: package main import \"fmt\" func helper(nums []int, res *[][]int, tmp []int, level int) { if len(tmp) \u003c= len(nums) { //长度一样的tmp用的是同一个地址，故可能会存在覆盖值得情况， // 长度不一样时重新开辟空间，将已有得元素复制进去 //*res = append(*res, tmp) 如此处，最终长度为1的tmp会被最后3这个元素全部覆盖 //以下相当于每次重新申请内存，使其指向的地址不一样，解决了最后地址一样的元素值被覆盖的状态状态 var a []int a = append(a, tmp[:] ...) //res = append(res, a) 如果此处不是指针引用传递，在append后，res重新分配内存，与之前传进来的res地址不一样，最终res仍为空值 *res = append(*res, a) } //fmt.Println(*res, \"---\u003e\", tmp) for i := level; i \u003c len(nums); i ++ { tmp = append(tmp, nums[i]) helper(nums, res, tmp, i + 1) tmp = tmp[:len(tmp) - 1] //相当于删除tmp末位的最后一个元素 } } func subsets(nums []int) [][]int { if len(nums) == 0 { return nil } var res [][]int var tmp []int helper(nums, \u0026res, tmp, 0) return res } func main() { pre := []int{1, 2, 3} fmt.Println(subsets(pre)) } //错误结果：[[] [3] [1 3] [1 2 3] [1 3] [3] [2 3] [3]]， 可以看出，长度为1的切片都被3覆盖了，这由于它们的地址不一样 //正确输出：[[] [1] [1 2] [1 2 3] [1 3] [2] [2 3] [3]]， 这是因为每次都为a分配内存，其地址都与之前的不一样，故最终的值没有被覆盖 ","date":"2020-08-02","objectID":"/golang/:1:3","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2 协程(coroutine) 在讲 goroutine 之前让我们先了解一下协程 (coroutine)，和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。它避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。 ","date":"2020-08-02","objectID":"/golang/:2:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. golang 的协程(goroutine) Goroutine 和其他语言的协程（coroutine）在使用方式上类似，但在区别上看，协程不是并发的，而Goroutine支持并发的。因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。来看个例子: func Hello() { fmt.Println(\"hello everybody , I'm Junqi Liao\") } func main() { go Hello() fmt.Println(\"Golang梦工厂\") } 上面的程序，我们使用go又开启了一个 goroutine 执行 Hello 方法，但是我们运行这个程序，运行结果如下: Golang梦工厂 这里出现这个问题的原因是我们启动的 goroutine 在 main 执行完就退出了。解决办法可以用 channel 通信让 goroutine 告诉 main 我执行完了，您再打印 “Golang梦工厂”。 func Hello(ch chan int) { fmt.Println(\"hello everybody , I'm asong\") ch \u003c- 1 } func main() { ch := make(chan int) go Hello(ch) \u003c-ch fmt.Println(\"Golang梦工厂\") } ","date":"2020-08-02","objectID":"/golang/:2:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. goroutine 的调度模型 M代表线程 P代表处理器，每一个运行的M（线程）都必须绑定一个P（处理器） G代表 goroutine，每次使用 go 关键字的时候，都会创建一个G对象 图3：GMP调度模型GMP调度模型 \" 图3：GMP调度模型 当前有两个P，各自绑定了一个M，每个P上挂了一个本地 goroutine 队列，也有一个全局 goroutine 队列。流程： 每次使用 go 关键字声明时，一个G对象被创建并加入到本地G队列或者全局G队列。 检查是否有空闲的P（处理器），若有那么创建一个M（若有正在 sleep 的M那么直接唤醒它）与其绑定，然后这个M循环执行 goroutine 任务。 G任务执行的顺序是，先从本地队列中找。但若某个M（线程）发现本地队列为空，那么会从全局队列中截取 goroutine 来执行（一次性转移（全局队列的G个数/P个数））。如果全局队列也空，那么会随机从别的P那里截取 “一半” 的 goroutine 过来（偷窃任务），若所有的P的队列都为空，那么该M（线程）就会陷入 sleep。 ","date":"2020-08-02","objectID":"/golang/:2:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3. goroutine 协程池 超大规模并发的场景下，不加限制的大规模的 goroutine 可能造成内存暴涨，给机器带来极大的压力，吞吐量下降和处理速度变慢还是其次，更危险的是可能使得程序 crash。所以，goroutine 池化是有其现实意义的。 首先，100w个任务，是不是真的需要100w个 goroutine 来处理？ 未必！用1w个 goroutine 也一样可以处理，让一个 goroutine 多处理几个任务就是了嘛，池化的核心优势就在于对 goroutine 的复用。此举首先极大减轻了 runtime 调度 goroutine 的压力，其次，便是降低了对内存的消耗。 Goroutine Pool 的实现思路大致如下： 启动服务之时先初始化一个 Goroutine Pool 池，这个 Pool 维护了一个类似栈的 LIFO 队列 ，里面存放负责处理任务的 Worker，然后在 client 端提交 task 到 Pool 中之后，在 Pool 内部，接收 task 之后的核心操作是： 检查当前 Worker 队列中是否有空闲的 Worker，如果有，取出执行当前的 task； 没有空闲 Worker，判断当前在运行的 Worker 是否已超过该 Pool 的容量，是 — 阻塞等待直至有 Worker 被放回 Pool；否 — 新开一个 Worker（goroutine）处理； 每个 Worker 执行完任务之后，放回 Pool 的队列中等待。 按照这个设计思路，一个高性能的 goroutine Pool，较好地解决了上述的大规模调度和资源占用的问题，在执行速度和内存占用方面相较于原生 goroutine 并发占有明显的优势，尤其是内存占用，因为复用，所以规避了无脑启动大规模 goroutine 的弊端，可以节省大量的内存。 ","date":"2020-08-02","objectID":"/golang/:2:3","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3 等待组 WaitGroup 很多情况下，我们正需要知道 goroutine 是否完成。这需要借助 sync 包的 WaitGroup 来实现。WaitGroup 是 sync 包中的一个 struct 类型，用来收集需要等待执行完成的 goroutine。下面是它的定义： type WaitGroup struct { // Has unexported fields. } // A WaitGroup waits for a collection of goroutines to finish. The main // goroutine calls Add to set the number of goroutines to wait for. Then each // of the goroutines runs and calls Done when finished. At the same time, Wait // can be used to block until all goroutines have finished. // A WaitGroup must not be copied after first use. func (wg *WaitGroup) Add(delta int) func (wg *WaitGroup) Done() func (wg *WaitGroup) Wait() 它有3个方法： Add()：每次激活想要被等待完成的 goroutine 之前，先调用 Add()，用来设置或添加要等待完成的 goroutine 数量例如 Add(2) 或者两次调用 Add(1) 都会设置等待计数器的值为2，表示要等待2个 goroutine 完成 Done()：每次需要等待的 goroutine 在真正完成之前，应该调用该方法来人为表示 goroutine 完成了，该方法会对等待计数器减1 Wait()：在等待计数器减为0之前，Wait() 会一直阻塞当前的 goroutine package main import ( \"fmt\" \"sync\" \"time\" ) func process(i int, wg *sync.WaitGroup) { fmt.Println(\"started Goroutine \", i) time.Sleep(2 * time.Second) fmt.Printf(\"Goroutine %d ended\\n\", i) wg.Done() } func main() { no := 3 var wg sync.WaitGroup for i := 0; i \u003c no; i++ { wg.Add(1) go process(i, \u0026wg) } wg.Wait() fmt.Println(\"All go routines finished executing\") } 上面激活了3个 goroutine，每次激活 goroutine 之前，都先调用 Add() 方法增加一个需要等待的 goroutine 计数。每个 goroutine 都运行 process() 函数，这个函数在执行完成时需要调用 Done() 方法来表示 goroutine 的结束。激活3个 goroutine 后，main goroutine 会执行到 Wait()，由于每个激活的 goroutine 运行的 process() 都需要睡眠2秒，所以 main goroutine 在 Wait() 这里会阻塞一段时间(大约2秒)，当所有 goroutine 都完成后，等待计数器减为0，Wait() 将不再阻塞，于是 main goroutine 得以执行后面的 Println()。 还有一点需要特别注意的是 process() 中使用指针类型的 *sync.WaitGroup 作为参数，这里不能使用值类型的 sync.WaitGroup 作为参数，因为这意味着每个 goroutine 都拷贝一份 wg，每个 goroutine 都使用自己的 wg。这显然是不合理的，这3个 goroutine 应该共享一个 wg，才能知道这3个 goroutine 都完成了。实际上，如果使用值类型的参数，main goroutine 将会永久阻塞而导致产生死锁。 ","date":"2020-08-02","objectID":"/golang/:3:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"4 channel channel 主要采用 CSP 并发模型实现的原理：不要通过共享内存来通信，而要通过通信来实现内存共享。它分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。 ","date":"2020-08-02","objectID":"/golang/:4:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. 非缓冲的 channel 无缓冲的通道只有当发送方和接收方都准备好时才会传送数据, 否则准备好的一方将会被阻塞。 ","date":"2020-08-02","objectID":"/golang/:4:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. 带缓冲的 channel 有缓冲的 channel 区别在于只有当缓冲区被填满时, 才会阻塞发送者, 只有当缓冲区为空时才会阻塞接受者。值得注意的是， 关闭 channel 以后仍然可以读取数据 for range 循环可以持续从一个 channel 中接收数据 ","date":"2020-08-02","objectID":"/golang/:4:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3. channel 的底层实现 1 channel 底层结构体 图4：channel 底层结构体channel1 \" 图4：channel 底层结构体 buf 是有缓冲的 channel 所特有的结构，用来存储缓存数据。是个循环链表 sendx 和 recvx 用于记录 buf 这个循环链表中的~发送或者接收的 ~index lock 是个互斥锁。 recvq 和 sendq 分别是接收 (\u003c-channel) 或者发送 (channel \u003c- xxx) 的 goroutine 抽象出来的结构体 (sudog) 的队列。是个双向链表 channel 的实现借助于结构体 hchan, 如下： type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex } 2 send/recv 的细化操作 缓存链表中以上每一步的操作，都是需要加锁操作的！ 每一步的操作的细节可以细化为： 第一，加锁 第二，把数据从 goroutine 中 copy 到“队列”中(或者从队列中 copy 到 goroutine 中）。 第三，释放锁 goroutine 内存 copy 到 channel: 图5：内存条 copy 进 channelchannel2 \" 图5：内存条 copy 进 channel channel 中的内存 copy 到 goroutine: 图6：channel 内存 copy 到内存条channel3 \" 图6：channel 内存 copy 到内存条 3. goroutine 的阻塞操作 goroutine 的阻塞操作，实际上是调用 send (ch \u003c- xx) 或者 recv ( \u003c-ch) 的时候主动触发的， //goroutine1 中，记做G1 ch := make(chan int, 3) ch \u003c- 1 ch \u003c- 1 ch \u003c- 1 当 channel 缓存满了以后，再次进行 send 操作 (ch\u003c-1) 的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用， 图7：Goroutine 调度channel4 \" 图7：Goroutine 调度 同时G1也会被抽象成含有G1指针和 send 元素的 sudog 结构体保存到 hchan 的 sendq 中等待被唤醒。直到另一个 goroutine G2从缓存队列中取出数据，channel 会将等待队列中的G1推出，将G1当时 send 的数据推到缓存中，然后调用 Go 的 scheduler，唤醒G1，并把G1放到可运行的 goroutine 队列中。 ","date":"2020-08-02","objectID":"/golang/:4:3","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"4. channel 可能出现的状态 操作 nil的channel 正常的channel 已关闭的channel \u003c- ch 阻塞 成功或阻塞 读到零值 ch \u003c- 阻塞 成功或阻塞 panic close(ch) panic 成功 panic ","date":"2020-08-02","objectID":"/golang/:4:4","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"5 context 包 context 包主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。可以通过简化对于处理单个请求的多个 Goroutine 之间与请求域的数据、超时和退出等操作。来看两个例子： package main import( \"context\" \"sync\" \"fmt\" \"time\" ) // 我们定义一个worker function func worker(ctx context.Context, wg *sync.WaitGroup) error { defer wg.Done() for { select { case \u003c- ctx.Done(): return ctx.Err() default: fmt.Println(\"hello\") } } } func main(){ ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second) var wg sync.WaitGroup for i := 0; i \u003c 10; i++{ wg.Add(1) go worker(ctx, \u0026wg) } time.Sleep(time.Second) cancel() wg.Wait() } 当并发体超时或者 main 主动停止 worker goroutine 时，worker goroutine 都可以安全退出。 另外在使用 context 时有两点值得注意：上游任务仅仅使用 context 通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说 context 的取消操作是无侵入的；context 是线程安全的，因为 context 本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。 ","date":"2020-08-02","objectID":"/golang/:5:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"6 defer，panic 和 recover ","date":"2020-08-02","objectID":"/golang/:6:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. defer 规则一：延迟函数的参数在 defer 语句出现时就已经确定下来了。例如： defer 语句中的 fmt.Println() 参数i值在 defer 出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响 fmt.Println() 函数的执行，仍然打印\"0\"。 func a() { i := 0 defer fmt.Println(i) i++ return } 规则二：延迟函数执行按后进先出顺序执行，即先出现的 defer 最后执行。 定义 defer 类似于入栈操作，执行 defer 类似于出栈操作。设计 defer 的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A–\u003eB–\u003eC，释放时往往又要反向进行。这就是把 deffer 设计成FIFO的原因。每申请到一个用完需要释放的资源时，立即定义一个 defer 来释放资源是个很好的习惯。例如： 函数拥有一个具名返回值 result，函数内部声明一个变量i，defer 指定一个延迟函数，最后返回变量i。延迟函数中递增 result。 函数输出2。函数的 return 语句并不是原子的，实际执行分为设置返回值–\u003eret，defer 语句实际执行在返回前，即拥有 defer 的函数返回过程是：设置返回值–\u003e执行 defer–\u003eret。所以 return 语句先把 result 设置为i的值，即1，defer 语句中又把 result 递增1，所以最终返回2。 func deferFuncReturn() (result int) { i := 1 defer func() { result++ }() return i } 规则三：延迟函数可能操作主函数的具名返回值。 定义 defer 的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer 所作用的函数，即延迟函数可能会影响到返回值。例如我们再看一下上面 deferFuncReturn() 的例子: func deferFuncReturn() (result int) { i := 1 defer func() { result++ }() return i } 该函数的 return 语句可以拆分成下面两行： result = i return 而延迟函数的执行正是在 return 之前，即加入 defer 后的执行过程如下： result = i result++ return 所以返回值为 result=1。 ","date":"2020-08-02","objectID":"/golang/:6:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. panic 主动：程序猿主动调用 panic() 函数； 被动：编译器的隐藏代码触发，或者内核发送给进程信号触发； panic 的具体实现，是依靠 defer 指针处理的，我们先来看一看 panic 的结构体： //runtime/runtime2.go type _panic struct { argp unsafe.Pointer // pointer to arguments of deferred call run during panic; cannot move - known to liblink arg interface{} // argument to panic link *_panic // link to earlier panic recovered bool // whether this panic is over aborted bool // the panic was aborted } _panic 是个结构体，存储了 defer 指针、参数，panic 列表的表头指针，和已恢复或已终止的信息。以下是 panic 的处理流程： 每个 goroutine 都有一个 panic 链表，运行时，遇到 panic 代码，会生成对应的 _panic 数据，存到这个链表的表头。 每执行完毕一个函数，如果没有 panic 发生，就跳过对应的 _panic 数据，回到正常流程，否则进入3。 如果有 panic 发生，处理链表中对应的 _panic，进入4。 如果 defer 链表（跟 panic 链表一样，也是每个 goroutine 一个）里存在 defer，按约定顺序执行延迟代码，进入5，否则进入8。 当 defer 链表执行到需要 recover 的时候，就交给 reflectcall 去调用 gorecover，进入6，否则进入7。 执行 recover，这时对应的 _panic 结构里的 recovered 字段标记为真，由 recovery 方法，负责安抚当前的 _panic，回到正常流程。 如果没 recover，那就进入死给你看流程，进入8。 最后，执行 fatalpanic 方法。 注意：因为 golang 的 gorotuine 机制，panic 在不同的 gorotuine 里面，是单独的，并不是整体处理。可能一个地方凉了，就会整体完蛋，这个要非常小心。 ","date":"2020-08-02","objectID":"/golang/:6:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3. recover Golang 虽然没有 try catch 机制，但它有类似 recover 的机制， package main import \"fmt\" func main() { fmt.Printf(\"%d\\n\", cal(1, 2)) fmt.Printf(\"%d\\n\", cal(5, 2)) fmt.Printf(\"%d\\n\", cal(5, 0)) fmt.Printf(\"%d\\n\", cal(9, 2)) } func cal(a, b int) int { defer func() { if err := recover(); err != nil { fmt.Printf(\"%s\\n\", err) } }() return a / b } 在 cal 函数里面每次终止的时候都会检查有没有异常产生，如果产生了我们可以处理，比如说记录日志，这样程序还可以继续执行下去。 ","date":"2020-08-02","objectID":"/golang/:6:3","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"7 interface ","date":"2020-08-02","objectID":"/golang/:7:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. 多态 interface 定义了一个或一组 method(s)，若某个数据类型实现了 interface 中定义的那些被称为 “methods” 的函数，则称这些数据类型实现（implement）了 interface。举个例子来说明。 //定义了一个Mammal的接口，当中声明了一个Say函数。 type Mammal interface { Say() } 定义 Cat、Dog 和 Human 三个结构体，分别实现各自的 Say 方法： type Dog struct{} type Cat struct{} type Human struct{} func (d Dog) Say() { fmt.Println(\"woof\") } func (c Cat) Say() { fmt.Println(\"meow\") } func (h Human) Say() { fmt.Println(\"speak\") } 之后，我们尝试使用这个接口来接收各种结构体的对象，然后调用它们的 Say 方法： func main() { var m Mammal m = Dog{} m.Say() m = Cat{} m.Say() m = Human{} m.Say() } // print result: // woof // meow // speak ","date":"2020-08-02","objectID":"/golang/:7:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. 类型断言 (type assertion) //类型断言 //一个判断传入参数类型的函数 func just(items ...interface{}) { for index, v := range items { switch v.(type) { case bool: fmt.Printf(\"%d params is bool,value is %v\\n\", index, v) case int, int64, int32: fmt.Printf(\"%d params is int,value is %v\\n\", index, v) case float32, float64: fmt.Printf(\"%d params is float,value is %v\\n\", index, v) case string: fmt.Printf(\"%d params is string,value is %v\\n\", index, v) case Student: fmt.Printf(\"%d params student,value is %v\\n\", index, v) case *Student: fmt.Printf(\"%d params *student,value is %v\\n\", index, v) } } } 我们聊了面向对象中多态以及接口、类型断言的概念和写法，借此进一步了解了为什么 golang 中的接口设计非常出色，因为它解耦了接口和实现类之间的联系，使得进一步增加了我们编码的灵活度，解决了供需关系颠倒的问题。 ","date":"2020-08-02","objectID":"/golang/:7:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"8 hashmap Hashmap 的内部结构是如何实现的呢？ ","date":"2020-08-02","objectID":"/golang/:8:0","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"1. 内部结构 Go的 map 是 unordered map，即无法对 key 值排序遍历。跟传统的 hashmap 的实现方法一样，它通过一个 buckets 数组实现，所有元素被 hash 到数组的 bucket 中，buckets 就是指向了这个内存连续分配的数组。B字段说明 hash 表大小是2的指数，即$2^B$。每次扩容会增加到上次大小的两倍，即 $2^{B+1}$。当 bucket 填满后，将通过 overflow 指针来 mallocgc 一个bucket出来形成链表，也就是为哈希表解决冲突问题。 // A header for a Go map. type hmap struct { count int // len()返回的map的大小 即有多少kv对 flags uint8 B uint8 // 表示hash table总共有2^B个buckets hash0 uint32 // hash seed buckets unsafe.Pointer // 按照low hash值可查找的连续分配的数组，初始时为16个Buckets. oldbuckets unsafe.Pointer nevacuate uintptr overflow *[2]*[]*bmap //溢出链 当初始buckets都满了之后会使用overflow } // A bucket for a Go map. type bmap struct { tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt values. // NOTE: packing all the keys together and then all the values together makes the // code a bit more complicated than alternating key/value/key/value/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // Followed by an overflow pointer. } bucket map 的数据结构中，tophash 是个大小为 8(bucketCnt) 的数组，存储了8个 key 的 hash 值的高八位值。 在对 key/value 对增删查的时候，先比较 key 的 hash 值高八位是否相等，然后再比较具体的key值。 ","date":"2020-08-02","objectID":"/golang/:8:1","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"2. map 初始化 ","date":"2020-08-02","objectID":"/golang/:8:2","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Golang"],"content":"3. hash grow 扩容和迁移","date":"2020-08-02","objectID":"/golang/:8:3","tags":["Golang","goroutine","channel"],"title":"Golang 基础知识与框架体系","uri":"/golang/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2020-02-01","objectID":"/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式!  将此页保存为书签，以备将来参考! ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2020-02-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":null,"content":" Hyper Twister 是一个由 Peter (廖隽祺) 利用简洁、优雅且高效的 Hugo 框架开发的技术博客。 博主会不定时的分享关于各种热门技术，主要偏向后端开发、云原生以及其他热门技术栈等等。 ","date":"2020-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 Hyper Twister","uri":"/about/"},{"categories":null,"content":"关于我 我是毕业于加拿大滑铁卢大学的数学本科生。过去四年和八个月份的本科生涯, 我主修金融数学，纯数学和统计辅修。同时，我对数学和编程都很感兴趣。在我的闲暇时间，我学习当下最热门的编程语言之一, 过去十年谷歌开发的语言 Golang。 图1：学习golang的原因golang \" 图1：学习golang的原因 我学习Golang和做Golang后端开发工程师有三个简单的原因。首先，Golang 的特色之处在于 goroutine, 因为 goroutine 涉及到运行时的高并发和低开销的上下文转换。其次，Golang 的生态是由谷歌开发和维护，这很大程度上节省了 Golang 开发人员在真实生产环境下的开发时间。最后是因为，Golang 可以应用在很多技术栈，譬如 docker, Kubernetes 在云原生服务上开发应用等等。 ","date":"2020-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 Hyper Twister","uri":"/about/"},{"categories":null,"content":"感谢 感谢 Dillon 为 hugo 社区提供了这么棒的博客主题。 关于 LoveIt 的更多信息请查看 LICENSE 文件。 ","date":"2020-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 Hyper Twister","uri":"/about/"}]