<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>Golang 基础知识与框架体系 - Hyper Twister</title><meta name=Description content="这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。"><meta property="og:title" content="Golang 基础知识与框架体系">
<meta property="og:description" content="这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://hyper2t.github.io/golang/"><meta property="og:image" content="https://hyper2t.github.io/golang/featured-image.jpeg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-08-02T21:57:40+08:00">
<meta property="article:modified_time" content="2021-12-21T23:17:45+08:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://hyper2t.github.io/golang/featured-image.jpeg">
<meta name=twitter:title content="Golang 基础知识与框架体系">
<meta name=twitter:description content="这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。">
<meta name=application-name content="LoveIt">
<meta name=apple-mobile-web-app-title content="LoveIt"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/twister-32x32.ico>
<link rel=icon type=image/png sizes=32x32 href=/twister-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/twister-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hyper2t.github.io/golang/><link rel=prev href=https://hyper2t.github.io/basic-markdown-syntax/><link rel=next href=https://hyper2t.github.io/k8s/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Golang 基础知识与框架体系","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hyper2t.github.io\/golang\/"},"image":[{"@type":"ImageObject","url":"https:\/\/hyper2t.github.io\/golang\/featured-image.jpeg","width":1420,"height":720}],"genre":"posts","keywords":"Golang, goroutine, channel","wordcount":7420,"url":"https:\/\/hyper2t.github.io\/golang\/","datePublished":"2020-08-02T21:57:40+08:00","dateModified":"2021-12-21T23:17:45+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":{"@type":"ImageObject","url":"https:\/\/hyper2t.github.io\/images\/selfie-modified.png","width":283,"height":283}},"author":{"@type":"Person","name":"Peter (廖隽祺)"},"description":"这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。"}</script></head>
<body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':'dark'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'dark'==='dark')&&document.body.setAttribute('theme','dark')</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Hyper Twister"><span class=header-title-pre><i class="fas fa-home"></i></span>Hyper Twister</a>
</div>
<div class=menu>
<div class=menu-inner><a class=menu-item href=/posts/> 所有文章 </a><a class=menu-item href=/tags/> 标签 </a><a class=menu-item href=/categories/> 分类 </a><a class=menu-item href=/categories/documentation/> 文档 </a><a class=menu-item href=/about/> 关于 </a><a class=menu-item href=https://github.com/hyper2t/hyper2t.github.io title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/en/golang/>English</option><option value=/golang/ selected>简体中文</option></select>
</a><span class="menu-item search" id=search-desktop>
<input type=text placeholder id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div>
</div>
</div>
</header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/ title="Hyper Twister"><span class=header-title-pre><i class="fas fa-home"></i></span>Hyper Twister</a>
</div>
<div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div>
</div>
<div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div>
<a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
</a>
</div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/categories/documentation/ title>文档</a><a class=menu-item href=/about/ title>关于</a><a class=menu-item href=https://github.com/hyper2t/hyper2t.github.io title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw"></i></a><a href=javascript:void(0); class="menu-item theme-switch" title>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=javascript:void(0); class=menu-item title>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select onchange="location=this.value"><option value=/en/golang/>English</option><option value=/golang/ selected>简体中文</option></select>
</a></div>
</div>
</header>
<div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div>
</div>
<div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div>
</div>
<main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title></h2>
<div class=toc-content id=toc-content-auto></div>
</div><article class="page single"><h1 class="single-title animated flipInX">Golang 基础知识与框架体系</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=https://hyper2t.github.io title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw"></i>Peter (廖隽祺)</a></span>&nbsp;<span class=post-category></span></div>
<div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2020-08-02>2020-08-02</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;&nbsp;<span id=/golang/ class=leancloud_visitors data-flag-title="Golang 基础知识与框架体系">
<i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;
</span>&nbsp;</div>
</div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/golang/featured-image.jpeg data-srcset="/golang/featured-image.jpeg, /golang/featured-image.jpeg 1.5x, /golang/featured-image.jpeg 2x" data-sizes=auto alt=/golang/featured-image.jpeg title="这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。"></div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span></span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div>
<div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#1-数组和切片>1 数组和切片</a>
<ul>
<li><a href=#1-切片的本质>1. 切片的本质</a></li>
<li><a href=#2-切片的扩容>2. 切片的扩容</a></li>
<li><a href=#3-切片的传递问题>3. 切片的传递问题</a></li>
</ul>
</li>
<li><a href=#2-协程coroutine>2 协程(coroutine)</a>
<ul>
<li><a href=#1-golang-的协程goroutine>1. golang 的协程(goroutine)</a></li>
<li><a href=#2-goroutine-的调度模型>2. goroutine 的调度模型</a></li>
<li><a href=#3-goroutine-协程池>3. goroutine 协程池</a></li>
</ul>
</li>
<li><a href=#3-等待组-waitgroup>3 等待组 WaitGroup</a></li>
<li><a href=#4-channel>4 channel</a>
<ul>
<li><a href=#1-非缓冲的-channel>1. 非缓冲的 channel</a></li>
<li><a href=#2-带缓冲的-channel>2. 带缓冲的 channel</a></li>
<li><a href=#3-channel-的底层实现>3. channel 的底层实现</a>
<ul>
<li><a href=#1-channel-底层结构体>1 channel 底层结构体</a></li>
<li><a href=#2-sendrecv-的细化操作>2 send/recv 的细化操作</a></li>
<li><a href=#3-goroutine-的阻塞操作>3. goroutine 的阻塞操作</a></li>
</ul>
</li>
<li><a href=#4-channel-可能出现的状态>4. channel 可能出现的状态</a></li>
</ul>
</li>
<li><a href=#5-context-包>5 context 包</a></li>
<li><a href=#6-deferpanic-和-recover>6 defer，panic 和 recover</a>
<ul>
<li><a href=#1-defer>1. defer</a></li>
<li><a href=#2-panic>2. panic</a></li>
<li><a href=#3-recover>3. recover</a></li>
</ul>
</li>
<li><a href=#7-interface>7 interface</a>
<ul>
<li><a href=#1-多态>1. 多态</a></li>
<li><a href=#2-类型断言-type-assertion>2. 类型断言 (type assertion)</a></li>
</ul>
</li>
<li><a href=#8-hashmap>8 hashmap</a>
<ul>
<li><a href=#1-内部结构>1. 内部结构</a></li>
<li><a href=#2-map-初始化>2. map 初始化</a></li>
<li><a href=#3-hash-grow-扩容和迁移>3. hash grow 扩容和迁移</a></li>
</ul>
</li>
</ul>
</nav></div>
</div><div class=content id=content><p>这篇文章总结了 Golang 的知识体系和实际应用中用到的框架，包括其中的底层实现等等。</p>
<div class="details admonition note open">
<div class="details-summary admonition-title">
<i class="icon fas fa-pencil-alt fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>说起 Golang， 大家都会第一时间想到高并发和 Golang 作为主流的后端开发语言的优势，本文主要讲 Golang 主要知识体系，包括<strong>数组和切片</strong>、<strong>协程的调度</strong>原理、等待组 <strong>waitGroup</strong>、<strong>channel</strong> 的底层实现、互斥锁 <strong>mutex</strong> 的实现、<strong>interface</strong> 中的多态等等。</div>
</div>
</div>
<h2 id=1-数组和切片>1 数组和切片</h2>
<h3 id=1-切片的本质>1. 切片的本质</h3>
<p>切片的本质就是对底层数组的封装，它包含了三个信息</p>
<ul>
<li>底层数组的指针</li>
<li>切片的长度(len)</li>
<li>切片的容量(cap)</li>
</ul>
<p>切片的容量指的是<strong>数组中的头指针指向的位置至数组最后一位的长度</strong>。举个例子，现在有一个数组 <code>a := [8]int {0,1,2,3,4,5,6,7}</code>，切片 <code>s1 := a[:5]</code>，相应示意图如下</p>
<p><figure><a class=lightgallery href=/slice1.png title="切片 s1 和底层数组 a" data-thumbnail=/slice1.png data-sub-html="<h2>图1: 切片 s1 和底层数组 a</h2><p>切片 s1 和底层数组 a</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/slice1.png data-srcset="/slice1.png, /slice1.png 1.5x, /slice1.png 2x" data-sizes=auto alt=/slice1.png>
</a><figcaption class=image-caption>图1: 切片 s1 和底层数组 a</figcaption>
</figure></p>
<p>切片 <code>s2 := a[3:6]</code>，相应示意图如下：</p>
<p><figure><a class=lightgallery href=/slice2.png title="切片 s2 和底层数组 a" data-thumbnail=/slice2.png data-sub-html="<h2>图2：切片 s2 和底层数组 a</h2><p>切片 s2 和底层数组 a</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/slice2.png data-srcset="/slice2.png, /slice2.png 1.5x, /slice2.png 2x" data-sizes=auto alt=/slice2.png>
</a><figcaption class=image-caption>图2：切片 s2 和底层数组 a</figcaption>
</figure></p>
<h3 id=2-切片的扩容>2. 切片的扩容</h3>
<p>Go 中切片扩容的策略是这样的：</p>
<ul>
<li>如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。</li>
<li>一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。</li>
</ul>
<div class="details admonition tip open">
<div class="details-summary admonition-title">
<i class="icon fas fa-lightbulb fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。</div>
</div>
</div>
<p>举例</p>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>// make()函数创建切片
</span><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>()</span>
<span class=kd>var</span> <span class=nx>slices</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>)</span>
<span class=c1>//[0 0 0 0]
</span><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slices</span><span class=p>)</span>
<span class=c1>// 长度：4, 容量8
</span><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;长度：%d, 容量%d&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>slices</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>slices</span><span class=p>))</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<p>需要注意的是，golang 中没办法通过下标来给切片扩容，如果需要扩容，需要用到 <code>append</code></p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>slices2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>}</span>
<span class=nx>slices2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slices2</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slices2</span><span class=p>)</span>
<span class=c1>// 输出结果 [1 2 3 4 5]
</span></code></pre></td></tr></table>
</div>
</div><p>同时切片还可以将两个切片进行合并</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>// 合并切片
</span><span class=c1></span><span class=nx>slices3</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>6</span><span class=p>,</span><span class=mi>7</span><span class=p>,</span><span class=mi>8</span><span class=p>}</span>
<span class=nx>slices2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slices2</span><span class=p>,</span> <span class=nx>slices3</span><span class=o>...</span><span class=p>)</span>
<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>slices2</span><span class=p>)</span>
<span class=c1>// 输出结果  [1 2 3 4 5 6 7 8]
</span></code></pre></td></tr></table>
</div>
</div><h3 id=3-切片的传递问题>3. 切片的传递问题</h3>
<p>切片本身传递给函数形参时是引用传递，但 <code>append</code> 后，切片长度变化时会被重新分配内存，而原来的切片还是指向原来地址，致使与初始状况传进来的地址不一样，要想对其值有改变操作，需使用指针类型操作。</p>
<p>我们来看一道 leetcode 78:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go>
<span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>helper</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>res</span> <span class=o>*</span><span class=p>[][]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>tmp</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>level</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>tmp</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=p>{</span>
		<span class=c1>//长度一样的tmp用的是同一个地址，故可能会存在覆盖值得情况，
</span><span class=c1></span>		<span class=c1>// 长度不一样时重新开辟空间，将已有得元素复制进去
</span><span class=c1></span>		<span class=c1>//*res = append(*res, tmp) 如此处，最终长度为1的tmp会被最后3这个元素全部覆盖
</span><span class=c1></span>		<span class=c1>//以下相当于每次重新申请内存，使其指向的地址不一样，解决了最后地址一样的元素值被覆盖的状态状态
</span><span class=c1></span>		<span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span>
		<span class=nx>a</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>[:]</span> <span class=o>...</span><span class=p>)</span>
		<span class=c1>//res = append(res, a) 如果此处不是指针引用传递，在append后，res重新分配内存，与之前传进来的res地址不一样，最终res仍为空值
</span><span class=c1></span>		<span class=o>*</span><span class=nx>res</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=o>*</span><span class=nx>res</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span>
	<span class=p>}</span>
	<span class=c1>//fmt.Println(*res, &#34;---&gt;&#34;, tmp)
</span><span class=c1></span>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nx>level</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>);</span> <span class=nx>i</span> <span class=o>++</span> <span class=p>{</span>
		<span class=nx>tmp</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>tmp</span><span class=p>,</span> <span class=nx>nums</span><span class=p>[</span><span class=nx>i</span><span class=p>])</span>
		<span class=nf>helper</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=nx>res</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>,</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
		<span class=nx>tmp</span> <span class=p>=</span> <span class=nx>tmp</span><span class=p>[:</span><span class=nb>len</span><span class=p>(</span><span class=nx>tmp</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=c1>//相当于删除tmp末位的最后一个元素
</span><span class=c1></span>	<span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>subsets</span><span class=p>(</span><span class=nx>nums</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>[][]</span><span class=kt>int</span> <span class=p>{</span>
	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>nums</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
		<span class=k>return</span> <span class=kc>nil</span>
	<span class=p>}</span>
	<span class=kd>var</span> <span class=nx>res</span> <span class=p>[][]</span><span class=kt>int</span>
	<span class=kd>var</span> <span class=nx>tmp</span> <span class=p>[]</span><span class=kt>int</span>
	<span class=nf>helper</span><span class=p>(</span><span class=nx>nums</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>res</span><span class=p>,</span> <span class=nx>tmp</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
	<span class=k>return</span> <span class=nx>res</span>
<span class=p>}</span>


<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  <span class=p>{</span>
	<span class=nx>pre</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>subsets</span><span class=p>(</span><span class=nx>pre</span><span class=p>))</span>
<span class=p>}</span>
<span class=c1>//错误结果：[[] [3] [1 3] [1 2 3] [1 3] [3] [2 3] [3]]， 可以看出，长度为1的切片都被3覆盖了，这由于它们的地址不一样
</span><span class=c1>//正确输出：[[] [1] [1 2] [1 2 3] [1 3] [2] [2 3] [3]]， 这是因为每次都为a分配内存，其地址都与之前的不一样，故最终的值没有被覆盖
</span></code></pre></td></tr></table>
</div>
</div><h2 id=2-协程coroutine>2 协程(coroutine)</h2>
<p>在讲 goroutine 之前让我们先了解一下协程 (coroutine)，和线程类似，共享堆，不共享栈，协程的切换一般由程序员在代码中显式控制。它避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂。</p>
<h3 id=1-golang-的协程goroutine>1. golang 的协程(goroutine)</h3>
<p>Goroutine 和其他语言的协程（coroutine）在使用方式上类似，但在区别上看，协程不是并发的，而Goroutine支持并发的。因此Goroutine可以理解为一种Go语言的协程。同时它可以运行在一个或多个线程上。来看个例子:</p>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Hello</span><span class=p>()</span>  <span class=p>{</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello everybody , I&#39;m Junqi Liao&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  <span class=p>{</span>
 <span class=k>go</span> <span class=nf>Hello</span><span class=p>()</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Golang梦工厂&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<p>上面的程序，我们使用go又开启了一个 goroutine 执行 Hello 方法，但是我们运行这个程序，运行结果如下:</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback>Golang梦工厂
</code></pre></td></tr></table>
</div>
</div><p>这里出现这个问题的原因是我们启动的 goroutine 在 main 执行完就退出了。解决办法可以用 channel 通信让 goroutine 告诉 main 我执行完了，您再打印 “Golang梦工厂”。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>  <span class=p>{</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello everybody , I&#39;m asong&#34;</span><span class=p>)</span>
 <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span>  <span class=p>{</span>
 <span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
 <span class=k>go</span> <span class=nf>Hello</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
 <span class=o>&lt;-</span><span class=nx>ch</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Golang梦工厂&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id=2-goroutine-的调度模型>2. goroutine 的调度模型</h3>
<ul>
<li>M代表线程</li>
<li>P代表处理器，每一个运行的M（线程）都必须绑定一个P（处理器）</li>
<li>G代表 goroutine，每次使用 go 关键字的时候，都会创建一个G对象</li>
</ul>
<p><figure><a class=lightgallery href=/gmp.png title=GMP调度模型 data-thumbnail=/gmp.png data-sub-html="<h2>图3：GMP调度模型</h2><p>GMP调度模型</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/gmp.png data-srcset="/gmp.png, /gmp.png 1.5x, /gmp.png 2x" data-sizes=auto alt=/gmp.png>
</a><figcaption class=image-caption>图3：GMP调度模型</figcaption>
</figure></p>
<p>当前有两个P，各自绑定了一个M，每个P上挂了一个本地 goroutine 队列，也有一个全局 goroutine 队列。流程：</p>
<ul>
<li>每次使用 go 关键字声明时，一个G对象被创建并加入到本地G队列或者全局G队列。</li>
<li>检查是否有空闲的P（处理器），若有那么创建一个M（若有正在 sleep 的M那么直接唤醒它）与其绑定，然后这个M循环执行 goroutine 任务。</li>
<li>G任务执行的顺序是，先从本地队列中找。但若某个M（线程）发现本地队列为空，那么会从全局队列中截取 goroutine 来执行（一次性转移（全局队列的G个数/P个数））。如果全局队列也空，那么会随机从别的P那里截取 “一半” 的 goroutine 过来（偷窃任务），若所有的P的队列都为空，那么该M（线程）就会陷入 sleep。</li>
</ul>
<h3 id=3-goroutine-协程池>3. goroutine 协程池</h3>
<p>超大规模并发的场景下，不加限制的大规模的 goroutine 可能造成内存暴涨，给机器带来极大的压力，吞吐量下降和处理速度变慢还是其次，更危险的是可能使得程序 crash。所以，goroutine 池化是有其现实意义的。</p>
<div class="details admonition question open">
<div class="details-summary admonition-title">
<i class="icon fas fa-question-circle fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>首先，100w个任务，是不是真的需要100w个 goroutine 来处理？</div>
</div>
</div>
<p>未必！用1w个 goroutine 也一样可以处理，让一个 goroutine 多处理几个任务就是了嘛，池化的核心优势就在于对 goroutine 的复用。此举首先极大减轻了 runtime 调度 goroutine 的压力，其次，便是降低了对内存的消耗。</p>
<div class="details admonition tip open">
<div class="details-summary admonition-title">
<i class="icon fas fa-lightbulb fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><p>Goroutine Pool 的实现思路大致如下：</p>
<p>启动服务之时先初始化一个 Goroutine Pool 池，这个 Pool 维护了一个类似栈的 LIFO 队列 ，里面存放负责处理任务的 Worker，然后在 client 端提交 task 到 Pool 中之后，在 Pool 内部，接收 task 之后的核心操作是：</p>
<ul>
<li>检查当前 Worker 队列中是否有空闲的 Worker，如果有，取出执行当前的 task；</li>
<li>没有空闲 Worker，判断当前在运行的 Worker 是否已超过该 Pool 的容量，是 — 阻塞等待直至有 Worker 被放回 Pool；否 — 新开一个 Worker（goroutine）处理；</li>
<li>每个 Worker 执行完任务之后，放回 Pool 的队列中等待。</li>
</ul>
</div>
</div>
</div>
<p>按照这个设计思路，一个高性能的 goroutine Pool，较好地解决了上述的大规模调度和资源占用的问题，在执行速度和内存占用方面相较于原生 goroutine 并发占有明显的优势，尤其是内存占用，因为复用，所以规避了无脑启动大规模 goroutine 的弊端，可以节省大量的内存。</p>
<h2 id=3-等待组-waitgroup>3 等待组 WaitGroup</h2>
<p>很多情况下，我们正需要知道 goroutine 是否完成。这需要借助 <code>sync</code> 包的 <code>WaitGroup</code> 来实现。<code>WaitGroup</code> 是 <code>sync</code> 包中的一个 <code>struct</code> 类型，用来收集需要等待执行完成的 goroutine。下面是它的定义：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>WaitGroup</span> <span class=kd>struct</span> <span class=p>{</span>
        <span class=c1>// Has unexported fields.
</span><span class=c1></span><span class=p>}</span>
  <span class=c1>// A WaitGroup waits for a collection of goroutines to finish. The main
</span><span class=c1></span>  <span class=c1>// goroutine calls Add to set the number of goroutines to wait for. Then each
</span><span class=c1></span>  <span class=c1>// of the goroutines runs and calls Done when finished. At the same time, Wait
</span><span class=c1></span>  <span class=c1>// can be used to block until all goroutines have finished.
</span><span class=c1></span>
  <span class=c1>// A WaitGroup must not be copied after first use.
</span><span class=c1></span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Add</span><span class=p>(</span><span class=nx>delta</span> <span class=kt>int</span><span class=p>)</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Done</span><span class=p>()</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>wg</span> <span class=o>*</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=nf>Wait</span><span class=p>()</span>
</code></pre></td></tr></table>
</div>
</div><p>它有3个方法：</p>
<ul>
<li><code>Add()</code>：每次激活想要被等待完成的 goroutine 之前，先调用 <code>Add()</code>，用来设置或添加要等待完成的 goroutine 数量例如 <code>Add(2)</code> 或者两次调用 <code>Add(1)</code> 都会设置等待计数器的值为2，表示要等待2个 goroutine 完成</li>
<li><code>Done()</code>：每次需要等待的 goroutine 在真正完成之前，应该调用该方法来人为表示 goroutine 完成了，该方法会对等待计数器减1</li>
<li><code>Wait()</code>：在等待计数器减为0之前，<code>Wait()</code> 会一直阻塞当前的 goroutine</li>
</ul>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=p>(</span>  
    <span class=s>&#34;fmt&#34;</span>
    <span class=s>&#34;sync&#34;</span>
    <span class=s>&#34;time&#34;</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nf>process</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>wg</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=p>{</span>  
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;started Goroutine &#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Goroutine %d ended\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
    <span class=nx>no</span> <span class=o>:=</span> <span class=mi>3</span>
    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>no</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
        <span class=k>go</span> <span class=nf>process</span><span class=p>(</span><span class=nx>i</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>wg</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;All go routines finished executing&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面激活了3个 goroutine，每次激活 goroutine 之前，都先调用 <code>Add()</code> 方法增加一个需要等待的 goroutine 计数。每个 goroutine 都运行 <code>process()</code> 函数，这个函数在执行完成时需要调用 <code>Done()</code> 方法来表示 goroutine 的结束。激活3个 goroutine 后，main goroutine 会执行到 <code>Wait()</code>，由于每个激活的 goroutine 运行的 <code>process()</code> 都需要睡眠2秒，所以 main goroutine 在 <code>Wait()</code> 这里会阻塞一段时间(大约2秒)，当所有 goroutine 都完成后，等待计数器减为0，<code>Wait()</code> 将不再阻塞，于是 <code>main</code> goroutine 得以执行后面的 <code>Println()</code>。</p>
<div class="details admonition note open">
<div class="details-summary admonition-title">
<i class="icon fas fa-pencil-alt fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>还有一点需要特别注意的是 <code>process()</code> 中使用指针类型的 <code>*sync.WaitGroup</code> 作为参数，这里不能使用值类型的 <code>sync.WaitGroup</code> 作为参数，因为这意味着每个 goroutine 都拷贝一份 <code>wg</code>，每个 goroutine 都使用自己的 <code>wg</code>。这显然是不合理的，这3个 goroutine 应该共享一个 <code>wg</code>，才能知道这3个 goroutine 都完成了。实际上，如果使用值类型的参数，main goroutine 将会永久阻塞而导致产生死锁。</div>
</div>
</div>
<h2 id=4-channel>4 channel</h2>
<p><code>channel</code> 主要采用 CSP 并发模型实现的原理：不要通过共享内存来通信，而要通过通信来实现内存共享。它分为两种：带缓冲、不带缓冲。对不带缓冲的 <code>channel</code> 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。</p>
<h3 id=1-非缓冲的-channel>1. 非缓冲的 channel</h3>
<p>无缓冲的通道只有当发送方和接收方都准备好时才会传送数据, 否则准备好的一方将会被阻塞。</p>
<h3 id=2-带缓冲的-channel>2. 带缓冲的 channel</h3>
<p>有缓冲的 <code>channel</code> 区别在于只有当缓冲区被填满时, 才会阻塞发送者, 只有当缓冲区为空时才会阻塞接受者。值得注意的是，</p>
<ul>
<li>关闭 <code>channel</code> 以后仍然可以读取数据</li>
<li><code>for range</code> 循环可以持续从一个 <code>channel</code> 中接收数据</li>
</ul>
<h3 id=3-channel-的底层实现>3. channel 的底层实现</h3>
<h4 id=1-channel-底层结构体>1 channel 底层结构体</h4>
<p><figure><a class=lightgallery href=/channel1.png title=channel1 data-thumbnail=/channel1.png data-sub-html="<h2>图4：channel 底层结构体</h2><p>channel1</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/channel1.png data-srcset="/channel1.png, /channel1.png 1.5x, /channel1.png 2x" data-sizes=auto alt=/channel1.png>
</a><figcaption class=image-caption>图4：channel 底层结构体</figcaption>
</figure></p>
<ul>
<li><code>buf</code> 是有缓冲的 <code>channel</code> 所特有的结构，用来存储缓存数据。是个循环链表</li>
<li><code>sendx</code> 和 <code>recvx</code> 用于记录 <code>buf</code> 这个循环链表中的~发送或者接收的 <code>~index</code></li>
<li><code>lock</code> 是个互斥锁。</li>
<li><code>recvq</code> 和 <code>sendq</code> 分别是接收 (<code>&lt;-channel</code>) 或者发送 (<code>channel &lt;- xxx</code>) 的 goroutine 抽象出来的结构体 (<code>sudog</code>) 的队列。是个双向链表</li>
</ul>
<p><code>channel</code> 的实现借助于结构体 <code>hchan</code>, 如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>hchan</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>qcount</span>   <span class=kt>uint</span>           <span class=c1>// total data in the queue
</span><span class=c1></span>    <span class=nx>dataqsiz</span> <span class=kt>uint</span>           <span class=c1>// size of the circular queue
</span><span class=c1></span>    <span class=nx>buf</span>      <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// points to an array of dataqsiz elements
</span><span class=c1></span>    <span class=nx>elemsize</span> <span class=kt>uint16</span>
    <span class=nx>closed</span>   <span class=kt>uint32</span>
    <span class=nx>elemtype</span> <span class=o>*</span><span class=nx>_type</span> <span class=c1>// element type
</span><span class=c1></span>    <span class=nx>sendx</span>    <span class=kt>uint</span>   <span class=c1>// send index
</span><span class=c1></span>    <span class=nx>recvx</span>    <span class=kt>uint</span>   <span class=c1>// receive index
</span><span class=c1></span>    <span class=nx>recvq</span>    <span class=nx>waitq</span>  <span class=c1>// list of recv waiters
</span><span class=c1></span>    <span class=nx>sendq</span>    <span class=nx>waitq</span>  <span class=c1>// list of send waiters
</span><span class=c1></span>
    <span class=c1>// lock protects all fields in hchan, as well as several
</span><span class=c1></span>    <span class=c1>// fields in sudogs blocked on this channel.
</span><span class=c1></span>    <span class=c1>//
</span><span class=c1></span>    <span class=c1>// Do not change another G&#39;s status while holding this lock
</span><span class=c1></span>    <span class=c1>// (in particular, do not ready a G), as this can deadlock
</span><span class=c1></span>    <span class=c1>// with stack shrinking.
</span><span class=c1></span>    <span class=nx>lock</span> <span class=nx>mutex</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id=2-sendrecv-的细化操作>2 send/recv 的细化操作</h4>
<p>缓存链表中以上每一步的操作，都是需要加锁操作的！</p>
<p>每一步的操作的细节可以细化为：</p>
<ul>
<li>第一，加锁</li>
<li>第二，把数据从 goroutine 中 copy 到“队列”中(或者从队列中 copy 到 goroutine 中）。</li>
<li>第三，释放锁</li>
</ul>
<p>goroutine 内存 copy 到 <code>channel</code>:</p>
<p><figure><a class=lightgallery href=/channel2.png title=channel2 data-thumbnail=/channel2.png data-sub-html="<h2>图5：内存条 copy 进 channel</h2><p>channel2</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/channel2.png data-srcset="/channel2.png, /channel2.png 1.5x, /channel2.png 2x" data-sizes=auto alt=/channel2.png>
</a><figcaption class=image-caption>图5：内存条 copy 进 channel</figcaption>
</figure></p>
<p><code>channel</code> 中的内存 copy 到 goroutine:</p>
<p><figure><a class=lightgallery href=/channel3.png title=channel3 data-thumbnail=/channel3.png data-sub-html="<h2>图6：channel 内存 copy 到内存条</h2><p>channel3</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/channel3.png data-srcset="/channel3.png, /channel3.png 1.5x, /channel3.png 2x" data-sizes=auto alt=/channel3.png>
</a><figcaption class=image-caption>图6：channel 内存 copy 到内存条</figcaption>
</figure></p>
<h4 id=3-goroutine-的阻塞操作>3. goroutine 的阻塞操作</h4>
<p>goroutine 的阻塞操作，实际上是调用 <code>send</code> (<code>ch &lt;- xx</code>) 或者 <code>recv</code> ( <code>&lt;-ch</code>) 的时候主动触发的，</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//goroutine1 中，记做G1
</span><span class=c1></span>
<span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>

<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
<span class=nx>ch</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</code></pre></td></tr></table>
</div>
</div><p>当 <code>channel</code> 缓存满了以后，再次进行 <code>send</code> 操作 (<code>ch&lt;-1</code>) 的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用，</p>
<p><figure><a class=lightgallery href=/channel4.png title=channel4 data-thumbnail=/channel4.png data-sub-html="<h2>图7：Goroutine 调度</h2><p>channel4</p>">
<img class=lazyload src=/svg/loading.min.svg data-src=/channel4.png data-srcset="/channel4.png, /channel4.png 1.5x, /channel4.png 2x" data-sizes=auto alt=/channel4.png>
</a><figcaption class=image-caption>图7：Goroutine 调度</figcaption>
</figure></p>
<p>同时G1也会被抽象成含有G1指针和 <code>send</code> 元素的 <code>sudog</code> 结构体保存到 <code>hchan</code> 的 <code>sendq</code> 中等待被唤醒。直到另一个 goroutine G2从缓存队列中取出数据，<code>channel</code> 会将等待队列中的G1推出，将G1当时 <code>send</code> 的数据推到缓存中，然后调用 Go 的 scheduler，唤醒G1，并把G1放到可运行的 goroutine 队列中。</p>
<h3 id=4-channel-可能出现的状态>4. channel 可能出现的状态</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>nil的channel</th>
<th>正常的channel</th>
<th>已关闭的channel</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;- ch</td>
<td>阻塞</td>
<td>成功或阻塞</td>
<td>读到零值</td>
</tr>
<tr>
<td>ch &lt;-</td>
<td>阻塞</td>
<td>成功或阻塞</td>
<td>panic</td>
</tr>
<tr>
<td>close(ch)</td>
<td>panic</td>
<td>成功</td>
<td>panic</td>
</tr>
</tbody>
</table>
<h2 id=5-context-包>5 context 包</h2>
<p><code>context</code> 包主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。可以通过简化对于处理单个请求的多个 Goroutine 之间与请求域的数据、超时和退出等操作。来看两个例子：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>
<span class=kn>import</span><span class=p>(</span>
	<span class=s>&#34;context&#34;</span>
	<span class=s>&#34;sync&#34;</span>
	<span class=s>&#34;fmt&#34;</span>
	<span class=s>&#34;time&#34;</span>
<span class=p>)</span>
<span class=c1>// 我们定义一个worker function
</span><span class=c1></span><span class=kd>func</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>ctx</span> <span class=nx>context</span><span class=p>.</span><span class=nx>Context</span><span class=p>,</span> <span class=nx>wg</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
  <span class=k>defer</span> <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>

  <span class=k>for</span> <span class=p>{</span>
    <span class=k>select</span> <span class=p>{</span>
    <span class=k>case</span> <span class=o>&lt;-</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Done</span><span class=p>():</span>
      <span class=k>return</span> <span class=nx>ctx</span><span class=p>.</span><span class=nf>Err</span><span class=p>()</span>
    <span class=k>default</span><span class=p>:</span>
      <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>)</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
  <span class=nx>ctx</span><span class=p>,</span> <span class=nx>cancel</span> <span class=o>:=</span> <span class=nx>context</span><span class=p>.</span><span class=nf>WithTimeout</span><span class=p>(</span><span class=nx>context</span><span class=p>.</span><span class=nf>Background</span><span class=p>(),</span> <span class=mi>10</span><span class=o>*</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>

  <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
  <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>{</span>
    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
    <span class=k>go</span> <span class=nf>worker</span><span class=p>(</span><span class=nx>ctx</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>wg</span><span class=p>)</span>
  <span class=p>}</span>
  <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
  <span class=nf>cancel</span><span class=p>()</span>

  <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div><p>当并发体超时或者 <code>main</code> 主动停止 <code>worker</code> goroutine 时，<code>worker</code> goroutine 都可以安全退出。</p>
<p>另外在使用 <code>context</code> 时有两点值得注意：上游任务仅仅使用 <code>context</code> 通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说 <code>context</code> 的取消操作是无侵入的；<code>context</code> 是线程安全的，因为 <code>context</code> 本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。</p>
<h2 id=6-deferpanic-和-recover>6 defer，panic 和 recover</h2>
<h3 id=1-defer>1. defer</h3>
<ul>
<li>
<p>规则一：延迟函数的参数在 <code>defer</code> 语句出现时就已经确定下来了。例如：</p>
<p><code>defer</code> 语句中的 <code>fmt.Println()</code> 参数i值在 defer 出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响 <code>fmt.Println()</code> 函数的执行，仍然打印"0"。</p>
</li>
</ul>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>a</span><span class=p>()</span> <span class=p>{</span>    
    <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span>
    <span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
    <span class=nx>i</span><span class=o>++</span>
    <span class=k>return</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<ul>
<li>
<p>规则二：延迟函数执行按后进先出顺序执行，即先出现的 <code>defer</code> 最后执行。</p>
<p>定义 <code>defer</code> 类似于入栈操作，执行 <code>defer</code> 类似于出栈操作。设计 <code>defer</code> 的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再跟据A资源申请B资源，跟据B资源申请C资源，即申请顺序是:A&ndash;>B&ndash;>C，释放时往往又要反向进行。这就是把 <code>deffer</code> 设计成FIFO的原因。每申请到一个用完需要释放的资源时，立即定义一个 <code>defer</code> 来释放资源是个很好的习惯。例如：</p>
<p>函数拥有一个具名返回值 <code>result</code>，函数内部声明一个变量<code>i</code>，<code>defer</code> 指定一个延迟函数，最后返回变量i。延迟函数中递增 <code>result</code>。</p>
<p>函数输出2。函数的 <code>return</code> 语句并不是原子的，实际执行分为设置返回值&ndash;>ret，<code>defer</code> 语句实际执行在返回前，即拥有 <code>defer</code> 的函数返回过程是：设置返回值&ndash;>执行 defer&ndash;>ret。所以 <code>return</code> 语句先把 <code>result</code> 设置为i的值，即1，<code>defer</code> 语句中又把 <code>result</code> 递增1，所以最终返回2。</p>
</li>
</ul>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>deferFuncReturn</span><span class=p>()</span> <span class=p>(</span><span class=nx>result</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>

  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>result</span><span class=o>++</span>
  <span class=p>}()</span>

  <span class=k>return</span> <span class=nx>i</span>
<span class=p>}</span>

</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<ul>
<li>
<p>规则三：延迟函数可能操作主函数的具名返回值。</p>
<p>定义 <code>defer</code> 的函数，即主函数可能有返回值，返回值有没有名字没有关系，<code>defer</code> 所作用的函数，即延迟函数可能会影响到返回值。例如我们再看一下上面 <code>deferFuncReturn()</code> 的例子:</p>
</li>
</ul>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>deferFuncReturn</span><span class=p>()</span> <span class=p>(</span><span class=nx>result</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
  <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span>

  <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>result</span><span class=o>++</span>
  <span class=p>}()</span>

  <span class=k>return</span> <span class=nx>i</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<p>该函数的 <code>return</code> 语句可以拆分成下面两行：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>result</span> <span class=p>=</span> <span class=nx>i</span>
<span class=k>return</span>
</code></pre></td></tr></table>
</div>
</div><p>而延迟函数的执行正是在 <code>return</code> 之前，即加入 <code>defer</code> 后的执行过程如下：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=nx>result</span> <span class=p>=</span> <span class=nx>i</span>
<span class=nx>result</span><span class=o>++</span>
<span class=k>return</span>
</code></pre></td></tr></table>
</div>
</div><p>所以返回值为 <code>result=1</code>。</p>
<h3 id=2-panic>2. panic</h3>
<ul>
<li>主动：程序猿主动调用 <code>panic()</code> 函数；</li>
<li>被动：编译器的隐藏代码触发，或者内核发送给进程信号触发；</li>
</ul>
<p><code>panic</code> 的具体实现，是依靠 <code>defer</code> 指针处理的，我们先来看一看 <code>panic</code> 的结构体：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//runtime/runtime2.go
</span><span class=c1></span><span class=kd>type</span> <span class=nx>_panic</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>argp</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// pointer to arguments of deferred call run during panic; cannot move - known to liblink
</span><span class=c1></span>    <span class=nx>arg</span> <span class=kd>interface</span><span class=p>{}</span> <span class=c1>// argument to panic
</span><span class=c1></span>    <span class=nx>link</span> <span class=o>*</span><span class=nx>_panic</span> <span class=c1>// link to earlier panic
</span><span class=c1></span>    <span class=nx>recovered</span> <span class=kt>bool</span> <span class=c1>// whether this panic is over
</span><span class=c1></span>    <span class=nx>aborted</span> <span class=kt>bool</span> <span class=c1>// the panic was aborted
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>_panic</code> 是个结构体，存储了 <code>defer</code> 指针、参数，<code>panic</code> 列表的表头指针，和已恢复或已终止的信息。以下是 <code>panic</code> 的处理流程：</p>
<ul>
<li>
<ol>
<li>每个 goroutine 都有一个 <code>panic</code> 链表，运行时，遇到 <code>panic</code> 代码，会生成对应的 <code>_panic</code> 数据，存到这个链表的表头。</li>
</ol>
</li>
<li>
<ol start=2>
<li>每执行完毕一个函数，如果没有 <code>panic</code> 发生，就跳过对应的 <code>_panic</code> 数据，回到正常流程，否则进入3。</li>
</ol>
</li>
<li>
<ol start=3>
<li>如果有 <code>panic</code> 发生，处理链表中对应的 <code>_panic</code>，进入4。</li>
</ol>
</li>
<li>
<ol start=4>
<li>如果 <code>defer</code> 链表（跟 <code>panic</code> 链表一样，也是每个 goroutine 一个）里存在 <code>defer</code>，按约定顺序执行延迟代码，进入5，否则进入8。</li>
</ol>
</li>
<li>
<ol start=5>
<li>当 <code>defer</code> 链表执行到需要 <code>recover</code> 的时候，就交给 <code>reflectcall</code> 去调用 gorecover，进入6，否则进入7。</li>
</ol>
</li>
<li>
<ol start=6>
<li>执行 <code>recover</code>，这时对应的 <code>_panic</code> 结构里的 recovered 字段标记为真，由 recovery 方法，负责安抚当前的 <code>_panic</code>，回到正常流程。</li>
</ol>
</li>
<li>
<ol start=7>
<li>如果没 <code>recover</code>，那就进入死给你看流程，进入8。</li>
</ol>
</li>
<li>
<ol start=8>
<li>最后，执行 <code>fatalpanic</code> 方法。</li>
</ol>
</li>
</ul>
<p>注意：因为 golang 的 gorotuine 机制，<code>panic</code> 在不同的 gorotuine 里面，是单独的，并不是整体处理。可能一个地方凉了，就会整体完蛋，这个要非常小心。</p>
<h3 id=3-recover>3. recover</h3>
<p>Golang 虽然没有 <code>try catch</code> 机制，但它有类似 <code>recover</code> 的机制，</p>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kn>package</span> <span class=nx>main</span>

<span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>

<span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nf>cal</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nf>cal</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nf>cal</span><span class=p>(</span><span class=mi>5</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d\n&#34;</span><span class=p>,</span> <span class=nf>cal</span><span class=p>(</span><span class=mi>9</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nf>cal</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=k>if</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>();</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s\n&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
		<span class=p>}</span>
	<span class=p>}()</span>
	<span class=k>return</span> <span class=nx>a</span> <span class=o>/</span> <span class=nx>b</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<p>在 <code>cal</code> 函数里面每次终止的时候都会检查有没有异常产生，如果产生了我们可以处理，比如说记录日志，这样程序还可以继续执行下去。</p>
<h2 id=7-interface>7 interface</h2>
<h3 id=1-多态>1. 多态</h3>
<p><code>interface</code> 定义了一个或一组 method(s)，若某个数据类型实现了 <code>interface</code> 中定义的那些被称为 &ldquo;methods&rdquo; 的函数，则称这些数据类型实现（implement）了 <code>interface</code>。举个例子来说明。</p>
<div class="details admonition example open">
<div class="details-summary admonition-title">
<i class="icon fas fa-list-ol fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//定义了一个Mammal的接口，当中声明了一个Say函数。
</span><span class=c1></span><span class=kd>type</span> <span class=nx>Mammal</span> <span class=kd>interface</span> <span class=p>{</span>
 <span class=nf>Say</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div></div>
</div>
</div>
<p>定义 <code>Cat</code>、<code>Dog</code> 和 <code>Human</code> 三个结构体，分别实现各自的 <code>Say</code> 方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>type</span> <span class=nx>Dog</span> <span class=kd>struct</span><span class=p>{}</span>

<span class=kd>type</span> <span class=nx>Cat</span> <span class=kd>struct</span><span class=p>{}</span>

<span class=kd>type</span> <span class=nx>Human</span> <span class=kd>struct</span><span class=p>{}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=nx>Dog</span><span class=p>)</span> <span class=nf>Say</span><span class=p>()</span> <span class=p>{</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;woof&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=nx>Cat</span><span class=p>)</span> <span class=nf>Say</span><span class=p>()</span> <span class=p>{</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;meow&#34;</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>h</span> <span class=nx>Human</span><span class=p>)</span> <span class=nf>Say</span><span class=p>()</span> <span class=p>{</span>
 <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;speak&#34;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>之后，我们尝试使用这个接口来接收各种结构体的对象，然后调用它们的 <code>Say</code> 方法：</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
 <span class=kd>var</span> <span class=nx>m</span> <span class=nx>Mammal</span>
 <span class=nx>m</span> <span class=p>=</span> <span class=nx>Dog</span><span class=p>{}</span>
 <span class=nx>m</span><span class=p>.</span><span class=nf>Say</span><span class=p>()</span>
 <span class=nx>m</span> <span class=p>=</span> <span class=nx>Cat</span><span class=p>{}</span>
 <span class=nx>m</span><span class=p>.</span><span class=nf>Say</span><span class=p>()</span>
 <span class=nx>m</span> <span class=p>=</span> <span class=nx>Human</span><span class=p>{}</span>
 <span class=nx>m</span><span class=p>.</span><span class=nf>Say</span><span class=p>()</span>
<span class=p>}</span>
<span class=c1>// print result:
</span><span class=c1>// woof
</span><span class=c1>// meow
</span><span class=c1>// speak
</span></code></pre></td></tr></table>
</div>
</div><h3 id=2-类型断言-type-assertion>2. 类型断言 (type assertion)</h3>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>//类型断言
</span><span class=c1>//一个判断传入参数类型的函数
</span><span class=c1></span><span class=kd>func</span> <span class=nf>just</span><span class=p>(</span><span class=nx>items</span> <span class=o>...</span><span class=kd>interface</span><span class=p>{})</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>items</span> <span class=p>{</span>
        <span class=k>switch</span> <span class=nx>v</span><span class=p>.(</span><span class=kd>type</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>case</span> <span class=kt>bool</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params is bool,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
        <span class=k>case</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int64</span><span class=p>,</span> <span class=kt>int32</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params is int,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
        <span class=k>case</span> <span class=kt>float32</span><span class=p>,</span> <span class=kt>float64</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params is float,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
        <span class=k>case</span> <span class=kt>string</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params is string,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
        <span class=k>case</span> <span class=nx>Student</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params student,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
        <span class=k>case</span> <span class=o>*</span><span class=nx>Student</span><span class=p>:</span>
            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%d params *student,value is %v\n&#34;</span><span class=p>,</span> <span class=nx>index</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>

        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们聊了面向对象中多态以及接口、类型断言的概念和写法，借此进一步了解了为什么 golang 中的接口设计非常出色，因为它<strong>解耦了接口和实现类之间的联系</strong>，使得进一步增加了我们编码的灵活度，解决了供需关系颠倒的问题。</p>
<h2 id=8-hashmap>8 hashmap</h2>
<div class="details admonition question open">
<div class="details-summary admonition-title">
<i class="icon fas fa-question-circle fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>Hashmap 的内部结构是如何实现的呢？</div>
</div>
</div>
<h3 id=1-内部结构>1. 内部结构</h3>
<p>Go的 map 是 unordered map，即无法对 key 值排序遍历。跟传统的 hashmap 的实现方法一样，它通过一个 buckets 数组实现，所有元素被 hash 到数组的 bucket 中，buckets 就是指向了这个内存连续分配的数组。<code>B</code>字段说明 hash 表大小是2的指数，即$2^B$。每次扩容会增加到上次大小的两倍，即 $2^{B+1}$。当 bucket 填满后，将通过 <code>overflow</code> 指针来 <code>mallocgc</code> 一个bucket出来形成链表，也就是为哈希表解决冲突问题。</p>
<div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td>
<td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=c1>// A header for a Go map.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
	<span class=nx>count</span> <span class=kt>int</span> <span class=c1>// len()返回的map的大小 即有多少kv对
</span><span class=c1></span>	<span class=nx>flags</span> <span class=kt>uint8</span>
	<span class=nx>B</span>     <span class=kt>uint8</span>  <span class=c1>// 表示hash table总共有2^B个buckets 
</span><span class=c1></span>	<span class=nx>hash0</span> <span class=kt>uint32</span> <span class=c1>// hash seed
</span><span class=c1></span>	<span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// 按照low hash值可查找的连续分配的数组，初始时为16个Buckets.
</span><span class=c1></span>	<span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> 
	<span class=nx>nevacuate</span>  <span class=kt>uintptr</span>      
	<span class=nx>overflow</span> <span class=o>*</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=o>*</span><span class=p>[]</span><span class=o>*</span><span class=nx>bmap</span> <span class=c1>//溢出链 当初始buckets都满了之后会使用overflow
</span><span class=c1></span><span class=p>}</span>

<span class=c1>// A bucket for a Go map.
</span><span class=c1></span><span class=kd>type</span> <span class=nx>bmap</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>tophash</span> <span class=p>[</span><span class=nx>bucketCnt</span><span class=p>]</span><span class=kt>uint8</span>
<span class=c1>// Followed by bucketCnt keys and then bucketCnt values.
</span><span class=c1>// NOTE: packing all the keys together and then all the values together makes the
</span><span class=c1>// code a bit more complicated than alternating key/value/key/value/... but it allows
</span><span class=c1>// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span><span class=c1>// Followed by an overflow pointer.
</span><span class=c1></span><span class=p>}</span>
</code></pre></td></tr></table>
</div>
</div><p>bucket map 的数据结构中，<code>tophash</code> 是个大小为 8(bucketCnt) 的数组，存储了8个 key 的 hash 值的高八位值。</p>
<div class="details admonition tip open">
<div class="details-summary admonition-title">
<i class="icon fas fa-lightbulb fa-fw"></i><i class="details-icon fas fa-angle-right fa-fw"></i>
</div>
<div class=details-content>
<div class=admonition-content>在对 key/value 对增删查的时候，先比较 key 的 hash 值高八位是否相等，然后再比较具体的key值。</div>
</div>
</div>
<h3 id=2-map-初始化>2. map 初始化</h3>
<h3 id=3-hash-grow-扩容和迁移>3. hash grow 扩容和迁移</h3></div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>&nbsp;<a class=git-hash href=https://github.com/hyper2t/hyper2t.github.io/commit/29df86addc51585fc476d093b5eb80c3123c4d98 target=_blank title="commit by hyper2t(1244240338@qq.com) 29df86addc51585fc476d093b5eb80c3123c4d98: 增加背景图片轮播功能">
<i class="fas fa-hashtag fa-fw"></i>29df86a</a></span>
</div>
<div class=post-info-license></div>
</div>
<div class=post-info-line>
<div class=post-info-md><span>
<a class=link-to-markdown href=/golang/index.md target=_blank></a>
</span></div>
<div class=post-info-share>
<span><a href=javascript:void(0); title=" Twitter" data-sharer=twitter data-url=https://hyper2t.github.io/golang/ data-title="Golang 基础知识与框架体系" data-hashtags=Golang,goroutine,channel><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title=" Facebook" data-sharer=facebook data-url=https://hyper2t.github.io/golang/ data-hashtag=Golang><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title=" Hacker News" data-sharer=hackernews data-url=https://hyper2t.github.io/golang/ data-title="Golang 基础知识与框架体系"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title=" Line" data-sharer=line data-url=https://hyper2t.github.io/golang/ data-title="Golang 基础知识与框架体系"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title=" 微博" data-sharer=weibo data-url=https://hyper2t.github.io/golang/ data-title="Golang 基础知识与框架体系" data-ralateuid="7289413661/profile?topnav=1&wvr=6&is_all=1"><i class="fab fa-weibo fa-fw"></i></a></span>
</div>
</div>
</div>
<div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/golang/>Golang</a>,&nbsp;<a href=/tags/goroutine/>goroutine</a>,&nbsp;<a href=/tags/channel/>channel</a></section>
<section>
<span><a href=javascript:void(0); onclick=window.history.back()></a></span>&nbsp;|&nbsp;<span><a href=/></a></span>
</section>
</div>
<div class=post-nav><a href=/basic-markdown-syntax/ class=prev rel=prev title="Markdown 基本语法"><i class="fas fa-angle-left fa-fw"></i>Markdown 基本语法</a>
<a href=/k8s/ class=next rel=next title="Kubernetes CRD Operator 开发系列">Kubernetes CRD Operator 开发系列<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id=comments><div id=valine class=comment></div><noscript>
Please enable JavaScript to view the comments powered by <a href=https://valine.js.org/>Valine</a>.
</noscript></div></article></div>
</main><footer class=footer>
<div class=footer-container><div class=footer-line>Powered by Hugo with LoveIt</div><div class=footer-line>
</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2020 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Hyper Twister</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div>
</div>
</footer></div>
<div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=/lib/valine/valine.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"",maxShownLines:80},comment:{valine:{appId:"QGzwQXOqs5JOhN4RGPOkR2mR-MdYXbMMI",appKey:"WBmoGyJtbqUswvfLh6L8iEBr",avatar:"mp",el:"#valine",emojiCDN:"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/",emojiMaps:{100:"1f4af.png",alien:"1f47d.png",anger:"1f4a2.png",angry:"1f620.png",anguished:"1f627.png",astonished:"1f632.png",black_heart:"1f5a4.png",blue_heart:"1f499.png",blush:"1f60a.png",bomb:"1f4a3.png",boom:"1f4a5.png",broken_heart:"1f494.png",brown_heart:"1f90e.png",clown_face:"1f921.png",cold_face:"1f976.png",cold_sweat:"1f630.png",confounded:"1f616.png",confused:"1f615.png",cry:"1f622.png",crying_cat_face:"1f63f.png",cupid:"1f498.png",dash:"1f4a8.png",disappointed:"1f61e.png",disappointed_relieved:"1f625.png",dizzy:"1f4ab.png",dizzy_face:"1f635.png",drooling_face:"1f924.png",exploding_head:"1f92f.png",expressionless:"1f611.png",face_vomiting:"1f92e.png",face_with_cowboy_hat:"1f920.png",face_with_hand_over_mouth:"1f92d.png",face_with_head_bandage:"1f915.png",face_with_monocle:"1f9d0.png",face_with_raised_eyebrow:"1f928.png",face_with_rolling_eyes:"1f644.png",face_with_symbols_on_mouth:"1f92c.png",face_with_thermometer:"1f912.png",fearful:"1f628.png",flushed:"1f633.png",frowning:"1f626.png",ghost:"1f47b.png",gift_heart:"1f49d.png",green_heart:"1f49a.png",grimacing:"1f62c.png",grin:"1f601.png",grinning:"1f600.png",hankey:"1f4a9.png",hear_no_evil:"1f649.png",heart:"2764-fe0f.png",heart_decoration:"1f49f.png",heart_eyes:"1f60d.png",heart_eyes_cat:"1f63b.png",heartbeat:"1f493.png",heartpulse:"1f497.png",heavy_heart_exclamation_mark_ornament:"2763-fe0f.png",hole:"1f573-fe0f.png",hot_face:"1f975.png",hugging_face:"1f917.png",hushed:"1f62f.png",imp:"1f47f.png",innocent:"1f607.png",japanese_goblin:"1f47a.png",japanese_ogre:"1f479.png",joy:"1f602.png",joy_cat:"1f639.png",kiss:"1f48b.png",kissing:"1f617.png",kissing_cat:"1f63d.png",kissing_closed_eyes:"1f61a.png",kissing_heart:"1f618.png",kissing_smiling_eyes:"1f619.png",laughing:"1f606.png",left_speech_bubble:"1f5e8-fe0f.png",love_letter:"1f48c.png",lying_face:"1f925.png",mask:"1f637.png",money_mouth_face:"1f911.png",nauseated_face:"1f922.png",nerd_face:"1f913.png",neutral_face:"1f610.png",no_mouth:"1f636.png",open_mouth:"1f62e.png",orange_heart:"1f9e1.png",partying_face:"1f973.png",pensive:"1f614.png",persevere:"1f623.png",pleading_face:"1f97a.png",pouting_cat:"1f63e.png",purple_heart:"1f49c.png",rage:"1f621.png",relaxed:"263a-fe0f.png",relieved:"1f60c.png",revolving_hearts:"1f49e.png",right_anger_bubble:"1f5ef-fe0f.png",robot_face:"1f916.png",rolling_on_the_floor_laughing:"1f923.png",scream:"1f631.png",scream_cat:"1f640.png",see_no_evil:"1f648.png",shushing_face:"1f92b.png",skull:"1f480.png",skull_and_crossbones:"2620-fe0f.png",sleeping:"1f634.png",sleepy:"1f62a.png",slightly_frowning_face:"1f641.png",slightly_smiling_face:"1f642.png",smile:"1f604.png",smile_cat:"1f638.png",smiley:"1f603.png",smiley_cat:"1f63a.png",smiling_face_with_3_hearts:"1f970.png",smiling_imp:"1f608.png",smirk:"1f60f.png",smirk_cat:"1f63c.png",sneezing_face:"1f927.png",sob:"1f62d.png",space_invader:"1f47e.png",sparkling_heart:"1f496.png",speak_no_evil:"1f64a.png",speech_balloon:"1f4ac.png","star-struck":"1f929.png",stuck_out_tongue:"1f61b.png",stuck_out_tongue_closed_eyes:"1f61d.png",stuck_out_tongue_winking_eye:"1f61c.png",sunglasses:"1f60e.png",sweat:"1f613.png",sweat_drops:"1f4a6.png",sweat_smile:"1f605.png",thinking_face:"1f914.png",thought_balloon:"1f4ad.png",tired_face:"1f62b.png",triumph:"1f624.png",two_hearts:"1f495.png",unamused:"1f612.png",upside_down_face:"1f643.png",weary:"1f629.png",white_frowning_face:"2639-fe0f.png",white_heart:"1f90d.png",wink:"1f609.png",woozy_face:"1f974.png",worried:"1f61f.png",yawning_face:"1f971.png",yellow_heart:"1f49b.png",yum:"1f60b.png",zany_face:"1f92a.png",zipper_mouth_face:"1f910.png",zzz:"1f4a4.png"},enableQQ:!1,highlight:!0,lang:"",pageSize:10,placeholder:"",recordIP:!0,serverURLs:"https://leancloud.hugoloveit.com",visitor:!0}},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.zh-cn",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js></script>
<script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js></script><script type=text/javascript src=/js/custom.js></script></body>
</html>